### 검사합(checksum)

- 데이터의 오류 여부 확인 방법으로 널리 사용됨
- 일정 자릿수를 정하고 범위를 넘는 자리 올림은 버려서 자릿수를 유지함
- 보안성이 없음. 기밀성이나 무결성이 없다는 거임


### Hash(함수)의 특징

- 단방향성
- 입력 값의 크기와 상관 없이 결과 값이 길이(혹은 크기)가 일정
- 데이터 무결성 확보와 관련해 IT기술 전반에서 사용됨
  - 무결성 : 데이터가 위/변조되지 않았다
- 나머지 구하는 것과 비슷 : 몫을 버린 나머지만을 가지고 원래 값을 못 찾아낸다

대표적인 Hash 알고리즘
- MD-5 : 패스워드 단방향 암호화에 사용금지(인증체계 패스워드 암호화)
  - 경우의 수가 적음. 길이가 너무 짧음. Brute Force 기법으로 공격때리면 쉽게 뚫림
- SHA-1
- SHA-128, 256, 384, 512
  - 숫자가 클수록 경우의 수가 많아 충돌 가능성이 적고 보안성도 뛰어남

사용자 인증 기반
- 소지 : 열쇄
- 지식 : 암기(패스워드) -> 가성비 제일 뛰어남
  - 패스워드는 단방향 암호화를 해라 -> Hash 써라. 절대 평문으로 저장하면 안 된다
- 생체 : 지문
- 위치

Salt?
- 내부자들만 알고 있는 값. 강제로 잡아 늘린 이 값들
- 예) 원래 pw가 `1234`라면, salt한 거는 -> `TEST__1234__!` 이런 식임
- 이렇게 솔트(첨가물) 쳐서 Hash를 하면 설령 결과가 유출된다 하더라도 `Test__`, `__!`이라는 솔트값이랑 일치하는 걸 찾아내기 힘듦
- 원래 값이 있으면 첨가함으로싸 보안성을 증가시키는 데 쓰이는 값


대표적인 Hash 기술 활용 예
- 무결성 확보
  - 인증서 검증
  - 디지털 포렌식
  - 디지털 서명(Hash + PKI)
- 패스워드 단방향 암호화
- 블록체인
  - 어떤 정보가 있으면, 그 정보 전체를 통으로
  - f(x) -> y
    - y가 검사합처럼 Hashsum 형태로 Hash 결과가 나옴. 이 결과를 가지고 또 다른 정보가 있는데, 이 문서에 대해 
  - 본질은 DB같은 거임. DB의 데이터를 이루는 덩어리를 하나의 Block이라 하고, 이 block에 대한 무결성 확보하자고 Hash 기술 적용했는데, 이 Hash 형태를 쭉 체인 형태로 연결해놓은 거. -> 이렇게 해서 변조가 불가능하게 하는 DB같은 역할을 하는 기술
  - 데이터에 대한 무결성을 쉽게 확보할 수 있음


### 대칭키 (Symmetric key)

- 키 하나로 암호화/복호화를 모두 수행하는 방식
  - 암호화한다 = 보안성을 부여한다
- 비대칭키 방식에 비해 효율적
- DES, 3DES, SEED-128, ARIA, AES-128, AES-256 알고리즘
- 얘가 털리면 끝나기 때문에 어떻게 보관하는지도 중요함


### 비대칭키 (Asymmetric key)

- 한 쌍의 키가 서로 상호작용하는 구조를 가짐
- 두 키 중 하나로 암호화하면 쌍을 이루는 다른 키로 복호화함
- 보통 Public key와 Private key로 구분하며 PKI(Public Key Infrastructure) 기술의 근간을 이룸
  - Public key : 키 두개 중에 하나를 공개하는 것
  - Private key : 남한테 안 보여주고 나만 알고 있음
  - Public key로 암호화했으면 Private key로 복호화, Private key로 암호화했으면 Public key로 복호화
- RSA-2048, ECC 알고리즘이 있음
- 소수만이 비대칭키가 될 수 있음
- 예)
  -
  ```
    65 ^ 5 mod 323 = 12
    12 ^ 29 mod 323 = 65
  ```
  평문 숫자가 65(대문자 A)이고 암호화 키는 5, 복호화 키는 29, Modulus가 323
    - 12 ^ 29는 어마무시하게 큰 수
    - 12 ^ X mod 323 = 65에 대한 X를 찾으면 암호체계를 무력화할 수 있음


### 디지털 서명

- private key로 해시 결과를 암호화하는 것
- 원본 문서의 해시를 계산하고 Public key로 풀어 비교
- Hash를 나의 Private key로 싹 다 암호화 -> 이걸 풀어서 Hash 내용을 봐야 하는데, 이를 풀 수 있는 건 Private key와 그의 쌍을 이루는 Public key로 풀 수 있음
- 문서를 줄 때, 문서와 검증할 수 있는 Public key를 같이 줌 -> 위변조 여부 보려면 Hash를 계산함 -> 이 Hash가 암호화돼있지만 Public key로 풂 -> Hash 내용이 같으면 문서 내용이 위/변조되지 않았구나라는 거를 알 수 있음
- private key로 확실하게 자기서명했다는 거를 증명하기 위해 디지털 서명을 함
- private key로 Hash를 암호화하는 게 디지털 서명의 실체


### 대칭키 인터넷 환경 문제

- key도 정보임
  - Symmetric key(대칭키) 방식의 근본적인 문제
    - 인터넷이라고 하는 public 구간은 private한 정보가 노출되면 보안사고임 그래서 암호화를 해서 보내야함.
    - 만약 Symmetric key로 암호화한 후 서버로 전달하면 -> 이걸 다시 평문으로 복호화해서 풀어야 함 -> 이 키를 어떻게 서버로 안전하게 보낼 수 있을까? 없음
    - 그래서 대칭키를 안 쓰고 비대칭키를 씀
  - 비대칭키는
    - PC는 PC대로 Server는 Server대로 키(Public key, Private key 쌍) 생성을 먼저 한다
    - 인터넷에서 키를 교환함. 상대방한테 키를 보냄
    - PC는 서버한테 -> "내 public key"야. 서버는 PC한테 "어 그러면 이거 내 Public key보내줄게"
    - PC가 서버쪽으로 정보를 보내야 하는데, 이때 서버가 보내준 public key로 암호문을 만듦.
    - 서버는 public key와 쌍을 이루는, 자신이 갖고 있는 private key 를 가지고 암호문을 풂
    - 반대로 서버에서 PC로 암호문을 보낼 때는 PC의 public key로 암호화한 뒤 PC로 보냄 -> PC가 암호문을 풀 때는 자신의 private key로 풂
    - 이 사이에(암호문을 보낼 때) 비밀 통신 채널(secured channel), 터널이 하나 만들어짐
      - TCP/IP 연결 한 다음에 후 키교환하고 비밀통신을 했다 -> 그때의 세션을 Secured session, Tunnel이라고 함
    - 근데 public key도 해커가 알게되면 private key를 어느정도 유추할 수 있음 그래서 대칭키에 비해 키 길이가 긺
      - 왜냐하면 어느 정도 공개되다보니 경우의 수, 맞출 수 없는 숫자 범위를 대칭키만큼 맞추려다 보니 압도적으로 숫자 범위가 늘어남
      - 어차피 유통기한이 있으니, 그때 동안만 정보를 지키면 된다


### 대칭키와 비대칭키 혼용

PC가 Server와 비밀통신하려고 할 때
- 이때 서버쪽에서는 비대칭키 쌍을 생성 -> PC쪽에서는 대칭키 생성
  - 서버의 public key는 암호화(보안성 부여)하는데 사용 -> 그거를 PC쪽으로 보냄
    - PC의 대칭키를 서버의 public key로 암호화해서 Server로 보냄
    - 그 대칭키를 서버가 가진 private key로 복호화하여 대칭키 추출
    - 이러면 대칭키는 인터넷이라는 public 구간을 통과할 때 싹 암호화돼서 갔기 때문에 대칭키를 알아내기 힘듦
    - 그 후 평문을 대칭키로 암호화함 -> 암호문을 보냄 -> Server에서는 그 암호문을 이전 작업으로 받았던 대칭키로 풂
  - 그 반대의 경우에도, Server는 PC가 보내준 대칭키로 평문을 암호화한 뒤 보내면 -> PC쪽에서는 대칭키로 풀면 됨
  - 이때 PC가 만든 대칭키를 Session Key라고 함
    - 서버와 통신하는 여러 대의 PC가 있을 때 각자 개인의 key를 따로 쓸 거임. 세션 키는 통신하는 주체(채널)마다 키가 달라져서 보안성이 더 뛰어나질 수 있음
- 대칭키든 비대칭키든 생성하는 일은 부하가 많이 걸림


### 비대칭키 체계의 문제점

Server에서 보내준 거라고 PC 스스로 판단하는, 서버에서 날라온 public key를 신뢰해도 되는가?
- 검증 없이 믿어버린다면?
  - 해커들은 공격할 때 MITM(Man in the middle, 중간자 공격)을 함
  - PC와 Server 사이의 정보가 왔다갔다하는 경로에 해커가 끼어들어감, 즉 거쳐감(인라인 구조 비슷하게). 서버와 PC는 모름
  - Server가 키 쌍을 만드는 시점에 해커도 키 쌍을 만듦 -> Server가 PC한테 public key를 보낼 때 해커가 그걸 채감 -> 그러고나서 해커가 자기의 public key를 PC에 보내줌
  - PC입장에서 이 해커의 public key를 검증하지 않고 해커의 public key로 대칭키를 암호화해서 보내면 -> 해커가 이거를 다시 채가서 해커의 private key로 풂 -> PC의 session key가 나옴 -> 아까 서버가 보내준 public key로 해커가 그 session key를 암호화해서 서버한테 보냄
  - 앞으로의 PC에서 보내는 암호문은 모두 해커가 채갔던 session key로 풀어 평문을 볼 수 있게 됨
- PC는 원격지에서 정보가 오면 PC입장에서는 진짜 서버에서 온 게 맞는지 검증을 해야 함


### 공개키 신뢰를 위한 검증체계

- 키 쌍을 만드는데 많은 전산 자원이 소모되므로, 매번 생성하지 않고 일정 기간마다 1회만 생성함
- 클라이언트(PC) 입장에서 MITM 당하면 방법이 없으니 상호 인증할 수 있는 체계를 도입하자
  - RA(Registration Authority)로 감 -> 가서 "public key, private key 살게요"(인증서 구매) -> 등록 대행
  - RA가 CA(Certificate Authority)에다가 "abc.com에서 인증서 사겠대" -> 관련 인증서 생성해서 RA로 보냄
    - 인증서 생성은 보통 CA가 많이 함
    - 만약 CA에서 생성했다면 -> abc.com(서버)에 올라갈 public key, private key 쌍 생성
    - 이떄 public key에 정보를 잔뜩 넣음 -> 이거에 대한 무결성 검사를 확인할 수 있도록 Hash 결과도 넣음 -> X.509 형식을 갖춘 뭔가로 만듦 -> 이 만들어진 거를 인증서라고 함
  - 이 정보가 들어간 public key와 private key 쌍을 묶어서 RA에 주면 RA가 실무자한테 줌 -> 실무자가 웹 서버에다가 인증서를 설치함 -> 웹이므로 HTTP 통신을 함 -> 이때 이 인증서를 SSL인증서라고 부름 -> 이 인증서는 그래서 보통 6개월 ~ 1년짜리를 삼 -> 이 key 쌍을 웹 서버에다가 설치함 -> 그러니까 예전에는 단순 public key였는데, 이 public key가 public key를 포함한 X.509 형식의 인증서로 바뀜
  - PC가 HTTPS의 웹 서버에 접속하면 -> 웹서버에서 public key가 아니고 인증서가 날라감 -> 그러면 이를 어떻게 검증하냐? -> 검증이라고 하면
    - 예) 윈도우 OS를 쓰고 있다면, 마이크로소프트사가 CA(Verisign)회사와 제휴 관계가 되어, 검증이 가능하도록 MS쪽에서는 보안 업데이트를 할 때 PC에다가 기관 인증서라는 걸 설치함
    - 그래서 public key가 포함된 인증서가 날라오면 -> 설치했던 기관 인증서로 확인함
    - 이게 가능한 이유는 인증서에 Hash한 부분은 디지털 서명을 했다는 거임 -> 즉, 전체 내용이 있는데 위변조하면 안 되니 Hash해서 결과를 넣고 그 Hash를 CA의 private key로 Hash 결과를 암호화함
    - 이 기관 인증서라는 게, CA의 public key임. 그러니 해석할 때는 CA의 private key로 암호화한 거는 기관 인증서라는 (CA의) public key로 해석함
    - 그 Hash 결과를 보고 문서 전체를 Hash 해봤더니 그 Hash 결과와 같음 -> 같으면 조작되지 않은 거라고 판단하고 거기서 public key를 뽑은 다음에 검증을 끝내고 session key를 서버 쪽으로 전달함
- 이 인증서는 뜯어보면
  - X.509형식으로 기술된
    - 사용자 정보(위변조되면 안 됨)
    - public key(위변조되면 안 됨)
    - 암호화된 Hash
  - CA의 private key로 Hash 결과가 암호화되어 있으며, 검증 과정에서는 PC에 사전 배포된 CA Public Key(기관 인증서에 포함)로 암호를 풀어 검증할 수 있음
  - SSL 인증서를 검증하는 방법은 인증서를 발급한 CA의 인증서에 포함된 Public key를 이용해 SSL 인증서 Hash 결과를 복호화하면 됨
  - certmgr.msc(윈도우 명령어)
    - CA의 private key로 Hash 결과가 암호화되어 있으며, 검증 과정에서는 PC에 사전 배포된 CA public key(기관 인증서에 포함됨)로 암호를 풀어 SSL 인증서를 검증할 수 있음

PKI 인증체계
- PAA(Policy Approval Authorities, 과학기술정보통신부)
  - 공인 인증서에 대한 정책을 결정하고 하위 기관의 정책을 승인하는 기관. 우리나라는 미래창조과학부가 담당
- PCA(Policy Certification Authorities, 정책인증기관) 
  - RootCA를 발급하고 기본 정책을 수립하는 기관으로, 우리나라의 KISA가 여기에 해당함
  - RootCA는 모든 인증서의 기초가 되는 인증서를 보유하고 있으며, 인증서에 포함된 공개키에 대응되는 개인키로 생성한 자체 서명 인증서를 사용함
- CA(Certification Authority, 인증기관)
  - PCA의 하위 기관으로 인증서 발급과 취소 등의 실질적인 업무를 하는 기관
  - yessign(금융결제원), NCA(한국 전산원) 등이 이에 속하며, 상호 간 신뢰함
- RA(Registration Authority, 등록기관)
  - 사용자의 신분을 확인하고 CA 간 인터페이스를 제공하는 기관


### 해시 충돌이란?

서로 다른 데이터를 입력했는데 동일한 해시값이 나오는 것
상대적으로 무한한 입력 데이터데 비해, 해시로 표현할 수 있는 값은 유한하기 때문


### 단방향 암호화

- 암호화만 할 수 있고 복호화할 수 없는 암호화 기술
- 데이터의 기밀성보다는 무결성과 인증을 보장하는 데 중점을 둠


### 양방향 암호화의 키 종류

- 공개 키(public key) : 다른 사람과 공유할 수 있는 키로, 데이터를 암호화하거나 디지털 서명을 검증하는 데 사용됨
- 개인 키 = 비밀 기(private key) : 본인만 알고 있는 비밀 키로, 데이터를 복호화하거나 디지털 서명을 생성하는 데 사용됨
- 비 공개 키(secret key) : 대칭형 암호화에서 사용하는 키로, 암호화와 복호화에 동일한 키를 사용
- 대칭 키(symmetric key) : 암호화와 복호화에 같은 키를 사용하는 키로, 주로 빠른 데이터 전송에 사용됨